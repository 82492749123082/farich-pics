# [←](Home.md) `ClassicVsML` 
Сравнение работы классического алгоритма и алгоритма машинного
обучения

## Работа алгоритма машинного обучения

Для разделения сигнальных и фоновых пикселов в детекторе Farich мы 
использовали простую нейронную сеть архитектуры [U-Net](https://arxiv.org/abs/1505.04597), реализованную в [Minkowski Engine](https://github.com/NVIDIA/MinkowskiEngine) - библиотеке, обеспечивающей эффективные механизмы работы с разреженными данными (с помощью [Sparse Convolutional Neural Networks](https://www.cv-foundation.org/openaccess/content_cvpr_2015/papers/Liu_Sparse_Convolutional_Neural_2015_CVPR_paper.pdf)). 

Для наших целей генерировалась 1000 досок с 500 кругами на каждой, 800 из которых
использовались для тренировки нейронной сети. В качестве лосс-функции 
использовалась кросс-энтропия. Метрики проверялись на оставшихся 200 досках.

На google colab лежит [код](https://colab.research.google.com/drive/1ljftwmqe19-c-599EU9eDCdjy6fRLjiJ?usp=sharing) машинного алгоритма.

Время обучения нейронной сети составило менее одного часа. 
Время работы ML-алгоритма на одной entry составляет `~178 ms` (Google Colab, Tesla T4)

![Результаты](../sources/Results_neural.jpg)

## Работа классического алгоритма

В качестве классического алгоритма был использован
`Algorithms.classic_algo` из `farichlib`. Для наших целей
генерировалось 100 досок по 100 кругов в каждой (см. [код](https://github.com/82492749123082/farich-pics/blob/dev_yana/ClassicVsMl.ipynb))

Время работы классического алгоритма на одной entry составляет около 3 мс

![Результаты](../sources/Results_classic.jpg)

## Резюме

Видно, что алгоритм машинного обучения не превосходит классический
алгоритм ни по времени, ни по итоговым метрикам. 
